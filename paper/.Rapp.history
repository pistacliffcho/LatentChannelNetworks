library(nestedMM)
var1 = c(rep("cat", 90), rep("dog", 0) ) #
var2 = c(rep("cat", 0), rep("dog", 90) )#
y = factor( c(rep(0, length(var1)), rep(1, length(var2))) )#
df = data.frame(x = c(var1, var2), z = T )
mod = make_nestedMM(df, y, nComps = 2)
rm(list = ls() )
gc()
data = read.csv("~/Documents/loneFern/data/train_subset.csv")
summary(data)
data_noName = data[,1:16]
cor(data_noName)
rand_samp = data_noName[sample(nrow(data), 1000)]
rand_samp = data_noName[sample(nrow(data), 1000), ]
plot(rand_samp$TCP_RECV_COUNT, rand_samp$TCP_RECV_COUNT)
plot(rand_samp$TCP_RECV_COUNT, rand_samp$TCP_SEND_COUNT)
plot(log(rand_samp$TCP_RECV_COUNT), log(rand_samp$TCP_SEND_COUNT) )
webBrow_data = data_noName[data$PROCESSNAME_AGG == "web browser", ]
nonBrow_data = data_noName[data$PROCESSNAME_AGG != "web browser", ]
cor(webBrow_data)
cor(nonBrow_data)
summary(webBrow_data)
summary(nonBrow_data)
dataUse = data#
dataUse$LOCAL_PORT = NULL#
dataUse$REMOTE_PORT = NULL#
dataUse$PROCESSNAME_AGG = NULL
for(i in 1:ncol(dataUse))#
	dataUse[,i] = log(1 + dataUse[,i])
cor(dataUse)
plot(dataUse$TOTAL_EVENTS, dataUse$TCP_RECV_COUNT)
det( cor(dataUse) )
plot(dataUse$AVG_BYTES, dataUse$STDDEV_BYTES)
plot(dataUse$AVG_BYTES, dataUse$STDDEV_BYTES / dataUse$STDDEV_BYTES)
plot(dataUse$AVG_BYTES, dataUse$STDDEV_BYTES / dataUse$AVG_BYTES)
box_mull = funciton(u1, u2){#
	z0 = sqrt(-2 * log(u1)) * cos(2 * pi * u2)#
	z1 = sqrt(-2 * log(u1)) * sin(2 * pi * u2)#
	ans = cbind(z0, z1)#
	return(ans)#
}
box_mull = function(u1, u2){#
	z0 = sqrt(-2 * log(u1)) * cos(2 * pi * u2)#
	z1 = sqrt(-2 * log(u1)) * sin(2 * pi * u2)#
	ans = cbind(z0, z1)#
	return(ans)#
}
plot( box_mull(runif(1,100), runif(1, 100)))
box_mull = function(n = 100){#
	u1 = runif(n)#
	u2 = runif(n)#
	z0 = sqrt(-2 * log(u1)) * cos(2 * pi * u2)#
	z1 = sqrt(-2 * log(u1)) * sin(2 * pi * u2)#
	ans = cbind(z0, z1)#
	return(ans)#
}#
plot( box_mull())
plot( box_mull(1000))
box_mull = function(n = 100){#
	u1 = runif(n)#
	u2 = runif(n)#
	z0 = sqrt(-2 * log(u1)) * cos(2 * pi * u2)#
	z1 = sqrt(-2 * log(u2)) * sin(2 * pi * u1)#
	ans = cbind(z0, z1)#
	return(ans)#
}#
plot( box_mull(1000))
box_mull = function(n = 100){#
	u1 = runif(n)#
	u2 = runif(n)#
	z0 = sqrt(-2 * log(u1)) * cos(2 * pi * u2)#
	z1 = sqrt(-2 * log(u1)) * sin(2 * pi * u2)#
	ans = cbind(z0, z1)#
	return(ans)#
}#
plot( box_mull(1000))
plot( box_mull(1000))
data = read.csv("~/Documents/loneFern/data/train_subset.csv")
names(data)
library(mvtnorm)#
library(survival)#
#
n <- 100000#
set.seed(0)#
#
# set the correlation coefficient to be 0.5#
sigma <- matrix(c(1,0.5,0.5,1), ncol=2)#
X <- rmvnorm(n=n, mean=c(0,0), sigma=sigma)#
#
x1 <- X[,1]#
x2 <- X[,2]#
#
b1 <- 1#
b2 <- 3#
#
# relative hazards#
relhazs <- exp(b1*x1 + b2*x2)#
#
# event times#
# assume baseline hazard is a constant function at 1#
# so the survival times are simply exp distributed#
etimes <- rexp(n, relhazs)#
#
# assume no censorship for simplicity#
status <- rep(1, n)#
#
dat <- data.frame(id=1:n,#
                  time=etimes,#
                  status=status,#
                  x1=x1,#
                  x2=x2)
library(icenReg); fit_ph = ic_par(cbind(time, time) ~ x1, data = dat, model = "ph");fit_ph; fit_aft = ic_par(cbind(time, time) ~ x1, data = dat, model = "aft");fit_aft
library(icenReg); fit_ph = ic_par(cbind(time, time) ~ x1, data = dat, model = "ph", dist = "exponential");fit_ph; fit_aft = ic_par(cbind(time, time) ~ x1, data = dat, model = "aft", dist = "exponential");fit_aft
sigma <- matrix(c(1,0.5,0.5,1), ncol=2) * .25#
X <- rmvnorm(n=n, mean=c(0,0), sigma=sigma)#
#
x1 <- X[,1]#
x2 <- X[,2]#
#
b1 <- 1#
b2 <- 3#
#
# relative hazards#
relhazs <- exp(b1*x1 + b2*x2)#
#
# event times#
# assume baseline hazard is a constant function at 1#
# so the survival times are simply exp distributed#
etimes <- rexp(n, relhazs)#
#
# assume no censorship for simplicity#
status <- rep(1, n)#
#
dat <- data.frame(id=1:n,#
                  time=etimes,#
                  status=status,#
                  x1=x1,#
                  x2=x2)#
library(icenReg); fit_ph = ic_par(cbind(time, time) ~ x1, data = dat, model = "ph");fit_ph; fit_aft = ic_par(cbind(time, time) ~ x1, data = dat, model = "aft");fit_aft
fit_ph = ic_par(cbind(time, time) ~ x1, data = dat, model = "ph", dist = "exponential");fit_ph; #
fit_aft = ic_par(cbind(time, time) ~ x1, data = dat, model = "aft", dist = "exponential");fit_aft
X = matrix(rnorm(300^2 * 2), ncol = 2 )
S = t(X) %*% X
system.time( S = t(X) %*% X )
system.time( S <- t(X) %*% X )
system.time(chol(S))
X = matrix(rnorm(300^2 * 2), ncol = 2 ) #
system.time( S <- t(X) %*% X )#
system.time(chol(S))
dim(S)
dim(X)
X = matrix(rnorm(300^2 * 2), ncol = 300 )
system.time( S <- t(X) %*% X )
system.time(chol(S))
dim(S)
install.packges("nimble")
install.packages("nimble")
library(latChanNet)#
library(igraph)#
library(grid)#
#
set.seed(123)#
#
plot_width = 10#
plot_height = 7#
#
## NOTE: TO GET PLOTS TO SAVE CORRECTLY, MUST USED R, NOT RSTUDIO!#
## ALSO NEEDED TO RUN TWICE FOR SOME REASON#
#
setwd("/Users/andersonberg1/Documents/GitHub/LatentChannelNetworks/paper")#
#
## Sampling SBM#
p_in = 0.25#
p_out = 0.025#
nGrp = 10#
nPerGrp = 100#
block_membership = rep(1:nGrp, each = nPerGrp)#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
# Sampling#
sbm1 = sample_sbm(nGrp * nPerGrp, p_mat, rep(nPerGrp, nGrp) )#
sbm1_edgeList = as_edgelist(sbm1)#
#
# Fitting#
mod1 = makeLCN(sbm1_edgeList, nGrp)#
emLCN(mod1, iters = 10000)#
# Plotting#
pdf("baseSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod1, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = "")#
dev.off()#
#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
## Sampling SBM with highly connected block#
p_mat_aug = cbind(p_mat, p_in)#
p_mat_aug = rbind(p_mat_aug, p_in)#
block_membership = c(block_membership, #
                     rep(nGrp + 1, nPerGrp))#
sbm2 = sample_sbm( (nGrp + 1) * nPerGrp, #
                   p_mat_aug, #
                   rep(nPerGrp, nGrp + 1) )#
sbm2_edgeList = as_edgelist(sbm2)#
# Fitting#
mod2 = makeLCN(sbm2_edgeList, nGrp)#
emLCN(mod2, iters = 10000)#
# Plotting#
heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "Channel Frequency by Node for Stochastic Block Model")#
#
pdf("augSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "")#
dev.off()
# Constructing probability matrix
library(latChanNet)#
library(igraph)#
library(grid)#
#
set.seed(123)#
#
plot_width = 10#
plot_height = 7#
#
## NOTE: TO GET PLOTS TO SAVE CORRECTLY, MUST USED R, NOT RSTUDIO!#
## ALSO NEEDED TO RUN TWICE FOR SOME REASON#
#
setwd("/Users/andersonberg1/Documents/GitHub/LatentChannelNetworks/paper")#
#
## Sampling SBM#
p_in = 0.25#
p_out = 0.025#
nGrp = 10#
nPerGrp = 100#
block_membership = rep(1:nGrp, each = nPerGrp)#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
# Sampling#
sbm1 = sample_sbm(nGrp * nPerGrp, p_mat, rep(nPerGrp, nGrp) )#
sbm1_edgeList = as_edgelist(sbm1)#
#
# Fitting#
mod1 = makeLCN(sbm1_edgeList, nGrp)#
emLCN(mod1, iters = 10000)#
# Plotting#
pdf("baseSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod1, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = "")#
dev.off()#
#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
## Sampling SBM with highly connected block#
p_mat_aug = cbind(p_mat, p_in)#
p_mat_aug = rbind(p_mat_aug, p_in)#
block_membership = c(block_membership, #
                     rep(nGrp + 1, nPerGrp))#
sbm2 = sample_sbm( (nGrp + 1) * nPerGrp, #
                   p_mat_aug, #
                   rep(nPerGrp, nGrp + 1) )#
sbm2_edgeList = as_edgelist(sbm2)#
# Fitting#
mod2 = makeLCN(sbm2_edgeList, nGrp)#
emLCN(mod2, iters = 10000)#
# Plotting#
heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "Channel Frequency by Node for Stochastic Block Model")#
#
pdf("augSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "")#
dev.off()
library(latChanNet)#
library(igraph)#
library(grid)#
#
set.seed(123)#
#
plot_width = 10#
plot_height = 7#
#
## NOTE: TO GET PLOTS TO SAVE CORRECTLY, MUST USED R, NOT RSTUDIO!#
## ALSO NEEDED TO RUN TWICE FOR SOME REASON#
#
setwd("/Users/andersonberg1/Documents/GitHub/LatentChannelNetworks/paper")#
#
## Sampling SBM#
p_in = 0.25#
p_out = 0.025#
nGrp = 10#
nPerGrp = 100#
block_membership = rep(1:nGrp, each = nPerGrp)#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
# Sampling#
sbm1 = sample_sbm(nGrp * nPerGrp, p_mat, rep(nPerGrp, nGrp) )#
sbm1_edgeList = as_edgelist(sbm1)#
#
# Fitting#
mod1 = makeLCN(sbm1_edgeList, nGrp)#
emLCN(mod1, iters = 10000)#
# Plotting#
pdf("baseSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod1, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = "")#
dev.off()#
#
# Constructing probability matrix#
p_mat = matrix(p_out, nrow = nGrp, ncol = nGrp)#
diag(p_mat) = p_in#
## Sampling SBM with highly connected block#
p_mat_aug = cbind(p_mat, p_in)#
p_mat_aug = rbind(p_mat_aug, p_in)#
block_membership = c(block_membership, #
                     rep(nGrp + 1, nPerGrp))#
sbm2 = sample_sbm( (nGrp + 1) * nPerGrp, #
                   p_mat_aug, #
                   rep(nPerGrp, nGrp + 1) )#
sbm2_edgeList = as_edgelist(sbm2)#
# Fitting#
mod2 = makeLCN(sbm2_edgeList, nGrp)#
emLCN(mod2, iters = 10000)#
# Plotting#
heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "Channel Frequency by Node for Stochastic Block Model")#
#
pdf("augSBM.pdf", width = plot_width, height = plot_height)#
p = heatmapLCN(mod2, grp = block_membership, #
           xlab = "Nodes by Block", #
           ylab = "Channels", #
           main = #
             "")#
dev.off()
